diff --git a/CMakeLists.txt b/CMakeLists.txt
index a6aad7e9..4eabfab2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -447,20 +447,6 @@ if ("${CMAKE_BUILD_TYPE}" STREQUAL "")
   endif (DEBUG)
 endif ()
 string(TOUPPER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_UPPER)
-foreach (config ${CMAKE_BUILD_TYPE} ${CMAKE_CONFIGURATION_TYPES})
-  string(TOUPPER "${config}" config_upper)
-  foreach (var
-      CMAKE_C_FLAGS_${config_upper};
-      CMAKE_CXX_FLAGS_${config_upper};
-      CMAKE_EXE_LINKER_FLAGS_${config_upper};
-      CMAKE_MODULE_LINKER_FLAGS_${config_upper};
-      CMAKE_SHARED_LINKER_FLAGS_${config_upper})
-    set(${var} " ") # if "" defaults come back
-  endforeach ()
-endforeach ()
-foreach (var CMAKE_C_FLAGS;CMAKE_CXX_FLAGS)
-  set(${var} " ") # if "" defaults come back
-endforeach ()
 
 if (APPLE)
   # Enable @rpath for all shared library install names.
@@ -2018,3 +2004,5 @@ set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "DynamoRIO")
 set(CPACK_PACKAGE_RELOCATABLE "true")
 
 include(CPack)
+
+add_subdirectory(fuzz)
diff --git a/fuzz/CMakeLists.txt b/fuzz/CMakeLists.txt
new file mode 100644
index 00000000..e3b7b7c7
--- /dev/null
+++ b/fuzz/CMakeLists.txt
@@ -0,0 +1,5 @@
+if(DEFINED ENV{LIB_FUZZING_ENGINE})
+  add_executable(fuzz_disassemble fuzz_disassemble.cc)
+  configure_DynamoRIO_decoder(fuzz_disassemble)
+  target_link_libraries(fuzz_disassemble $ENV{LIB_FUZZING_ENGINE} pthread)
+endif()
diff --git a/fuzz/fuzz_disassemble.cc b/fuzz/fuzz_disassemble.cc
new file mode 100644
index 00000000..b7872ae5
--- /dev/null
+++ b/fuzz/fuzz_disassemble.cc
@@ -0,0 +1,31 @@
+#include <fcntl.h>
+
+#define DR_FAST_IR 1
+#include "dr_api.h"
+#include "droption.h"
+
+static int initialized = 0;
+static int flog;
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
+    if (initialized == 0) {
+        flog = open("/dev/null", 0);
+        initialized = 1;
+    }
+    void *dcontext = GLOBAL_DCONTEXT;
+    byte *pc = (byte *) Data;
+    byte *stop_pc = (byte *) Data + Size;
+    while (pc <= stop_pc) {
+        // Check ahead of time to see whether this instruction enters the redzone
+        // (or, we could disassemble into a buffer and check before printing it).
+        if (pc + decode_sizeof(dcontext, pc, NULL _IF_X86_64(NULL)) > stop_pc) {
+            break;
+        }
+        pc = disassemble_with_info(dcontext, pc, flog, false, true);
+        if (pc == NULL) {
+            break;
+        }
+    }
+    return 0;
+}
+
